from backend.services.prompts import format_chat_prompt, format_scraping_confirmation_prompt, tools
from openai import OpenAI
from backend.config import OPENAI_API_KEY
import logging
import time
from typing import Optional, List, Dict, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize OpenAI client
# Check if API key exists before initializing to provide better error messages
if OPENAI_API_KEY:
	openai = OpenAI(api_key=OPENAI_API_KEY)
else:
	logger.error("OPENAI_API_KEY is not set")
	openai = None

def generate_response(conversation_history: List[Dict[str, Any]] = None, relevant_info: str = None, attempts: int = 3) -> Optional[Any]:
	"""
	Generates a response from the OpenAI API using the Responses API.
	
	The system prompt (instructions) is generated by format_chat_prompt() and passed
	to the 'instructions' parameter. The conversation history is passed separately
	to the 'input' parameter.
	
	Args:
		conversation_history: The conversation history to use as input (list of message dicts).
			Each dict should have 'role' and 'content' keys, e.g.:
			[{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "Hi there"}]
		relevant_info: The relevant information collected from websites to answer the user's questions.
		attempts: Number of retry attempts if API call fails (default: 3)
	
	Returns:
		A string representing the generated response text, or None if all attempts failed
		or OpenAI client is not initialized
	"""
	if openai is None:
		logger.error("OpenAI client is not initialized - OPENAI_API_KEY not set")
		return None
	
	# Validate conversation_history format if provided
	if conversation_history is not None:
		if not isinstance(conversation_history, list):
			logger.warning("conversation_history should be a list, got {type(conversation_history)}")
			return None
		elif conversation_history and not all(isinstance(msg, dict) and 'role' in msg and 'content' in msg for msg in conversation_history):
			logger.warning("conversation_history items should be dicts with 'role' and 'content' keys")
			return None
	
	# Get system prompt (instructions) - no conversation history needed here
	system_prompt = format_chat_prompt(relevant_info)
	if conversation_history is None or len(conversation_history) == 0:
		logger.info("No conversation history provided.")
		return None
	counter = 0
	last_error = None
	while counter < attempts:
		try:
			response = openai.responses.create(
				model="gpt-4o-mini",
				tools=tools,
				instructions=system_prompt,
				input=conversation_history,
			)
			#logger.info(f"Response: {response}")
			return response #https://platform.openai.com/docs/api-reference/responses
			#return response.output_text #https://platform.openai.com/docs/api-reference/responses/object#responses-object-output_text
		except Exception as e:
			last_error = e
			logger.error(f"Error generating response (attempt {counter + 1}/{attempts}): {e}")
			counter += 1
			
			# Add delay between retries (exponential backoff)
			# This helps with rate limiting and transient network issues
			if counter < attempts:
				delay = min(2 ** counter, 10)  # Exponential backoff, max 10 seconds
				logger.info(f"Retrying in {delay} seconds...")
				time.sleep(delay)
	
	# All attempts failed
	logger.error(f"Failed to generate response after {attempts} attempts. Last error: {last_error}")
	return None

